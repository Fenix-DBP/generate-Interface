const fs=require("fs"),path=require("path"),{program}=require("commander"),prettier=require("prettier"),quoteIfNeeded=function(value){return/^[a-zA-Z_]\w*$/.test(value)?value:`"${value}"`},shouldUseType=function(value){return typeof value=="object"&&Object.keys(value).length===0||Array.isArray(value)||typeof value !== "object"},saveInterfaces=function(interfaces,output){try{fs.writeFileSync(output,interfaces),console.log(`Interfaces saved to: `,path.resolve(process.cwd(),output))}catch(error){console.error(`Error saving interfaces to file: `,error)}};program.option("-p, --path <filePath>","Path to the JSON file").option("-o, --output [outputFile]","Path to the output TypeScript file (default: outputInterfaces.ts)").parse(process.argv);const{path:jsonFilePath,output="outputInterfaces.ts"}=program.opts();jsonFilePath||(console.error("Error: Path to the JSON file is required. Use -p or --path option."),program.help()),(async()=>{try{const JSON_FILE=JSON.parse(fs.readFileSync(jsonFilePath,"utf-8")),interfacesContent=await generateInterface(JSON_FILE);saveInterfaces(interfacesContent,output)}catch(error){console.error(error)}})();async function generateInterface(JSON_FILE){try{const interfacesArray=[];for(const[key,value]of Object.entries(JSON_FILE)){const type=shouldUseType(value)?`type ${key} =`:`interface ${key}`,interfaceContent=`${type} ${await generateInterfaceType(value)};`;interfacesArray.push(interfaceContent)}interfacesArray.push(`interface ${path.basename(jsonFilePath,path.extname(jsonFilePath))} {\n${Object.entries(JSON_FILE).map(([i,_])=>`${quoteIfNeeded(i)}: ${quoteIfNeeded(i)}`).join(`
`)}\n}`);const interfacesContent=interfacesArray.join(`\n\n`);return prettier.format(interfacesContent,{parser:"typescript"})}catch{throw new Error("Failed to generate interfaces")}}async function generateInterfaceType(obj,indentation=2){if(Array.isArray(obj)){if(obj.length===0)return"any[]";const arrayType=await generateInterfaceType(obj[0]);return`${arrayType}[]`}else if(typeof obj=="object"){const properties=await Promise.all(Object.entries(obj).map(async([prop,value])=>{if(Array.isArray(value)&&!value.length)return`${quoteIfNeeded(prop)}: any[]`;const valueType=Array.isArray(value)?`${await generateInterfaceType(value[0])}[]`:await generateInterfaceType(value,indentation+2);return`${quoteIfNeeded(prop)}: ${valueType}`}));return`{\n${properties.join(`,\n`)}\n}`}else return typeof obj}
